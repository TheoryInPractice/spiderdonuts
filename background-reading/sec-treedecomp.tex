

Here we begin our forray into notions of structured sparsity. We start with one of the simpler notions, that of the \emph{degeneracy} of a graph $G$, which the Theory in Practice Lab has described as follows:
``No good notion of sparsity \emph{doesn't} imply bounded degeneracy." In other words, any good idea of $G$ having structured sparsity should imply that $G$ has bounded degeneracy. Next, we explore exactly what that means.


\subsection{Degeneracy and k-cores}\label{sec:degeneracy}

As usual, all graphs we consider here are standard graphs.
A \emph{$k$-core} is a graph in which every node had degree at least $k$. A $k$-core of a graph $G$ is any induced subgraph of $G$ that is also a $k$-core.
The \emph{$k$-core number of a node} $v$ in $G$ is the largest number $k$ for which $v$ is contained in a $k$-core of $G$.
The \emph{$k$-core of $G$} is the largest number $k$ for which $G$ has a $k$-core;
the $k$-core number of $G$ is also called the \emph{degeneracy} of $G$.


\subsubsection{Uses and Examples}

Degeneracy provides a much more useful notion of ``density" than, say, maximum degree or average degree.
For example, a star graph on $n$ nodes is a very sparse graph, yet it has maximum degree $n-1$, which ``sounds like it might be dense". In contrast, the degeneracy of a star is always 1, which reveals its  true sparsity.
Similarly, if a graph has constant average degree it does not guarantee any useful bound on the maximum clique size: an $n$ node graph with $kn$ edges can have a clique of size $\sim \sqrt{(k-1)n}$ (by constructing a path graph on $n$ nodes, then putting all other edges in a clique).
In contrast, the degeneracy of such a graph would be lower-bounded by the clique size, because a $k$-clique is always a $(k-1)$-core.

We could also think about this from the other direction, i.e. that the core number (degeneracy) of $G$ always gives a bound on the max clique number.
These bounds are not always useful, though: there are graphs with arbitrarily large gaps between the max-clique size and $k$-core number.
For example, a hypercube on $2^n$ nodes is always an $n$-core, but the largest clique is always of size 2.

Another useful feature related to degeneracy and core numbers is the idea of a \emph{degeneracy ordering} of a graph's nodes. This is any ordering on the nodes of $G$ that sorts the nodes, in ascending order, according to the nodes' $k$-core numbers. It is called the degeneracy ordering because if you delete these nodes, one-by-one, according to this ordering, then the core number of node $v$ is exactly equal to the degree of $v$ at the time $v$ is deleted. A degeneracy ordering can be useful for processing the nodes and edges of a graph in an efficient way.

For a linear-time algorithm that computes the $k$-core numbers of all nodes in $G$, see~\cite{batagelj2003m}. To use $k$-cores to accelerate computation of the max-clique in a graph, see~\cite{rossi2014fast}.

\subsubsection{Exercises}\label{sec:degeneracy:exercises}

\begin{enumerate}[label=\ref{sec:degeneracy}.\arabic*]
  \item If $G$ has maximum degree $d$, prove that degeneracy of $G$ is bounded above by $d$.
  \item If $G$ has degeneracy $k$, does this imply any upper bound on the number $n$ of nodes in the graph?
  For a fixed number of nodes $n$, does degeneracy $k$ imply an upper bound on the number of edges?
  \item If $G$ has degeneracy $k$, does this imply any lower bound on the number $n$ of nodes in the graph?
  For a fixed number of nodes $n$, does degeneracy $k$ imply a lower bound on the number of edges?
\end{enumerate}

\subsection{Tree-decompositions and tree-width}\label{sec:tree-decomposition}

% Merely having bounded degeneracy is not always enough to ensure that a difficult problem can be easily solved on a graph $G$. For example, computing the \emph{chromatic number} of a graph (i.e. the smallest number of colors necessary to color the vertices of $G$)
\paragraph{Definition}
We will, eventually, give a formal definition of a tree-decomposition of a graph $G$, but first we want to approach the topic intuitively.
A tree-decomposition is not ``a decomposition of a graph into trees" (this idea is closer to the \emph{arboricity} of a graph). Rather, a tree-decomposition is a map from the nodes of $G$ to some tree $T$ such that each node of $T$ (which we call a ``bag" and usually denote by $X_j$) contains a set of vertices of $G$, and we can think of $T$ as being a map of $G$ that tells us ``how to process the nodes of $G$ in an efficient order". Let's take the simplest possible type of tree for $T$, a path. If we have a tree-decomposition of $G$ such that its nodes are all mapped into bags of $T$ that are lined up in a path ($X_1, X_2, \cdots, X_k$), then to solve a problem on the entire graph $G$ it can suffice to simply perform computations on the nodes of $G$ one bag $X_j$ at a time before moving on to the next bag $X_{j+1}$.
To show why the tree-decomposition can be useful as a ``processing map", we next describe it more rigorously.

Formally, a \emph{tree-decomposition} of a graph $G = (V,E)$ consists of a tree $T = (V_T,E_T)$ whose nodes we call ``bags", such that:
\begin{enumerate}[label=T.\arabic*]
  \item Every node of $G$ is contained in at least one bag $X_j$ of $T$.
  \item Every edge of $G$ has both its endpoints contained in at least one bag $X_j$ of $T$.
  \item\label{def:tree-decomp:bag-rule} For each node $v$ in $G$, the set of bags $X_{j} \in V_T$ containing $v$ induces a connected subtree of $T$.
\end{enumerate}

Any such mapping from $G$ to a tree $T$ that satisfies these properties is a tree-decomposition of $G$; a given graph can have many tree-decompositions. For a given tree decomposition, we define the \emph{width} of the decomposition to be $\max_{X_j \in V_T}  (|X_j| - 1 )$. The \emph{tree-width} of the graph $G$, $\tw(G)$, is then the minimum width of all tree-decompositions of $G$.

\paragraph{Understanding its usefulness}
The basic idea of the usefulness of a tree decomposition is that the entire graph can be examined by simply examining all nodes in each bag, one bag at a time. If the graph has low tree-width, then no big is too large, and so each bag can be swiftly processed. Thus, ``graphs with bounded tree-width" is a class of structurally sparse graphs for which there exist a lot of fixed-parameter tractable algorithms, where the parameter that gets fixed is the tree-width of the graph, $\tr(G) = k$.

Tree-decompositions also have connections to vertex seperators. A \emph{vertex separator} of a connected graph $G = (V,E)$ is a set $S \subset V$ of nodes such that deleting $G - S$ is disconnected.
Vertex separators can be very useful in divide-and-conquer style algorithms, and in distributing graphs across multiuple processors for more efficient computation or storage.
It turns out that each bag $X_j$ in any tree decomposition of $G$ is a vertex separator.

An \emph{edge separator} of a connected graph $G = (V,E)$ is a set $F\subset E$ of edges such that $G-F$ is disconnected. This is also called an \emph{edge cut} or simply a \emph{cut}.
A cut, or edge separator $F$, is ``balanced" if deleting $F$ leaves behind two graph components that are not too different in size (this is a hand-wavey, intuitive term, not a rigorous once). To be more precise, we define the \emph{conductance} of a cut as follows. First note that any cut $F$ necessarily splits the set of nodes into two components,  $S$ and $G-S$. So, we can define a cut either by its edge set, $F$, or, equivalently, by the set of nodes that it disconnects, $F = \cut(S,G-S)$. Recalling that $\vol(S)$ is defined to be the sum of the degrees of the nodes in $S$, $\vol(S) = \sum_{v \in S} d(v)$, we can now define the condutance of the cut (edge separator) $F = \cut(S,G-S)$ to be
\begin{equation}\label{eqn:def:conductance}
  \text{conductance}(S) = \frac{\cut(S,G-S)}{\min\{ \vol(S), \vol(G-S) \} },
\end{equation}
which is conventionally denoted $\phi(S)$.
Note that condutance is always between 0 and 1; when $\phi(S) = 0$, the cut is very small because $S$ is not connected to the rest of $G$ (so the cut contains zero edges), whereas when $\phi(S) = 1$ the cut is larger, because all edges connected to nodes in $S$ leave the set $S$ and have their other endpoints in the set $G-S$ (so the cut contains a ``maximal" number of edges).

The connection of topics here is that every cut (edge separator) containing $t$ edges guarantees the existence of a vertex separator that contains no more than $t$ nodes. To see this, note that a cut $F = \cut(S,G-S)$ containing $t$ edges is incident to no more than $t$ nodes in $S$ (and no more than $t$ nodes in $G-S$). Thus, deleting those $s \leq t$ nodes will separate the graph into two pieces, and so some subset of the nodes in $S$ is a vertex separator.

\begin{proposition}
  Every cut (edge separator) in $G$ yields at least one vertex separator.
\end{proposition}

This provides a direct connection from conductance and cuts to vertex separators and, hence, tree-decompositions.
Thus, we next move our focus to eigenvalue approaches to understanding conductance and cuts in a graph.
Keep in mind that the benefit of tree decompositions is not the size of the tree $T$, but the width of the bags associated with the tree -- in other words, a tree decomposition is most helpful if all of the vertex separators it provides are small separators (contain a small number of nodes).


\subsubsection{Exercises}\label{sec:tree-decomposition:exercises}

\begin{enumerate}[label=\ref{sec:tree-decomposition}.\arabic*]
\item Let $G$ be a connected graph with a node $v$ of degree 1. Prove that deleting $v$ from $G$ does not disconnect $G$; i.e. prove that $(G-v)$ is connected.
\item Prove that a tree must have at least one node of degree 1. Then use that result to prove that a tree must have at least two nodes of degree 1.
\item Prove that a connected graph in which every node has degree at least 2 must contain at least one cycle.
\item Prove that every path graph $P$ has a tree-decomposition of tree-width 1. (Hint: take the path on $n$ nodes and tell how to construct construct the bags. (Sub-hint: width 1 means that each bag has exactly two nodes in it.) )
  \item Prove that if $G$ is a tree, then its tree-width is 1. (Hint: tree-width 1 means that the tree decomposition has width 1, which means every bag in that decomposition contains no more than 2 nodes.) (Hint 2: make a couple small trees and explicitly construct tree-decompositions for them with width 1. Notice anything about how each edge of the tree gets mapped to bags in the tree-decomposition? )
  \item Let $G = (V,E)$ be a connected graph. Let $G$ have a tree decomposition with tree $T=(V_T,E_T)$ (i.e. $V_T$ is the set of bags of the tree-decomposition).
  Fix any bag $X_j \in V_T$ and recall that a bag in a tree-decomposition consists of a set of nodes in the original graph, $G$.
  Let $G'$ be the graph that results from deleting from $G$ all nodes $v$ in the bag $X_j$, i.e. let $G' = G-X_j$.
  Prove that $G'$ is disconnected.
  (i.e. prove that each bag of a tree-decomposition for a graph $G$ gives rise to a vertex separator of $G$.)

  \item Prove that rule~\ref{def:tree-decomp:bag-rule} in the definition of tree-decomposition is equivalent to the following: ``for any two bags $X_i, X_j$ in the tree $T$, every bag $X$ on the path in $T$ connecting $X_i$ to $X_j$ must contain their intersection, i.e. $X_i \cap X_j \subseteq X$ ." (i.e. show that we could replace rule~\ref{def:tree-decomp:bag-rule} with this rule, and the resulting definition of tree-decomposition would be equivalent).
\end{enumerate}
