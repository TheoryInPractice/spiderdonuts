\documentclass[a4paper,10pt]{article}
\usepackage{amssymb,amsmath ,amsthm, graphicx}
\usepackage[left=2cm,top=2cm,right=2cm,bottom=3.5cm,nohead,nofoot]{geometry}
\usepackage{enumitem}

\input{preamble.tex}
\usepackage{csquotes}

% figure paths
\graphicspath{{.}{./figures/}}

%kyle's macros

\providecommand{\vvk}[2]{\vecn{#1}^{(#2)}}
\providecommand{\hvf}{\hvv{f}}
\providecommand{\dmax}{d_{\max}}
\providecommand{\floor}[1]{\left\lfloor #1 \right\rfloor}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{corollary}{Corollary}
\newtheorem{proposition}{Proposition}


%% MAIN TEXT
\title{Notes on walk-entropy}
\author{Kyle Kloster}


\begin{document}
\maketitle

\abstract{
Research journal on the walk-entropy problem, which started from Blair Sullivan and I considering a conjecture from Michele Benzi~\cite{benzi2014note} regarding the relationship of the walk-regularity of a graph to the diagonal of a function of the graph's adjacency matrix.

Since NCSU undergraduate Eric Horton joined the project, we've identified a handful more specific deceptive graphs, and eventually proved the existence of infinite families of deceptive graphs.
 }

\section{Problem Description}\label{sec:problem-statement}
\input{sec-problem-statement.tex}

\section{The two walk-class case} \label{sec:constructing-deceptive}
\input{sec-two-class.tex}

\section{Generalizing to multiple walk-classes}
\input{sec-generalizing-k-classes.tex}

\section{State of the project 2016-09-14}
\input{sec-update-2016-09-14.tex}

\section{Thoughts 2016-09-20}
\input{sec-week-2016-09-20.tex}

\section{Thoughts 2016-09-27}
\input{sec-week-2016-09-27.tex}

\section{An infinite family of deceptive graphs via the graph tensor product}
\input{sec-graph-tensor-product.tex}


\section{Implementation oddities}
I wanted to detail here a few interesting quirks about determining which diagonals $\diag(\mA^{p})$ to use in trying to construct the deceptive function coefficients.

\paragraph{Explaining the setting for max power}
First, the nonnegative linear system check has failed on a couple graphs that we know to be deceptive. The check failed on a couple snowflakecycle graphs when we ran the check with a full set of $n-1$ different columns in the walk-class--by--walk-length matrix $\mW$, i.e. when the function \verb|walk_classes| is called with \verb|max_power = n|.
But the check succeeded (and constructed an actual deceptive function that we can then verify by inspection) when we switched \verb|max_power| to 6 or 7 (it worked for both values 6 and 7).

This strange behavior is almost certainly because of numerical issues that arise from computing large powers of an adjacency matrix, and/or from handing the optimization algorithm a large number of columns to optimize over.
My personal suspicion is that large values of $n$ lead to very large numbers in $\mA^n$ \emph{that have to get added to numbers close to zero}. This leads to catestrophic cancellation and massive loss of precision.

To prevent this, we want to set \verb|max_power| to ensure that the difference between the largest number and number closest to zero that appear in the diagonals of $\mA^{j}$ are not too far apart. We know it is possible a 0 will appear in some diagonal $\mA^j$ (if a node is not part of a cycle of lengh 3, for example). The largest an entry could be is in a complete graph, a diagonal entry of $\mA^k$ would be bounded above by $(\dmax)^k$, where $\dmax$ is the maximum degree in the graph. For $\mA$ of dimension $n$, this is potentially as big as $(n-1)^k$.
The mantissa of a float64 is of size 53; thus, if $(\dmax)^k$ is larger than 53, the operation $fl\left((\dmax)^k + 0\right)$ will lose precision in floating point arithmetic.

\textbf{Setting the default value for $k$:}
Because of the numericla issues above, we need an upperbound on $k$ to avoid loss of precision. However, we need $k$ large enough to guarantee that the constraint matrix $\mW$ is sufficiently large to ensure feasible points for the optimization problem exist. In this section we discuss balancing these two forces.

The above numerical issues suggest that we should choose $k$ to satisfy $(\dmax)^k \leq 2^{53}$ to be on the safe side. This means choosing $k$ so that $k \leq 53 / \log_2(\dmax)$. We note that the problem never requires $k$ larger than $n$ (we have proved that if a solution exists with $k>n$, then a solution exists with $k \leq n$ -- really we don't need $k$ larger than the degree of the minimal polynomial of $\mA$). Thus, we can take $k = \min\left\{ \floor{ 53 / \log_2(\dmax) }, n \right\} $.  This upperbound would prevent us from choosing $k$ larger than it needs to be, or so large it would cause numerical errors.


At the same time, we want $k$ to be as large as is practical, to guarantee that the number of columns in the linear system $\mW$ is sufficient for a solution to exist.
Unfortunately, it is impossible to know what $k$ is big enough to guarantee $\mW$ has solutions without knowing in the first place that the graph is deceptive -- but this test is to check whether or not the graph \emph{is} deceptive! To escape this circularity, we have to simply pick a value for $k$ (and then potentially increase it if the check fails to find solutions).


In our experiments, we found that on larger graphs (where large values of $k$ can risk causing numerical issues if the graph is too dense), the value $k = 14$ was sufficiently large to ensure solutions could be found. This is not quite as ad-hoc as it may seem. The nonnegative linear system check essentially relies on different nodes having different numbers of $l$-cycles for several values of $l$. To be able to find these cycle lengths, the nonnegative linear system check has to use $k$ big enough that sufficiently many such values of $l$ are less than $k$. In all of our constructed deceptive graphs, $k = 14$ was large enough to capture sufficiently many smaller cycles. (These cycles were typically of length 3 to 9, by design).

By setting
\begin{equation}\label{eqn:def-max-power}
  k := \max\left\{ 14,  \min\left\{ \lfloor 53 / \log_2( \dmax ) \rfloor , n\right\}  \right\}
\end{equation}
we guarantee
\begin{itemize}
  \item  $k \leq n$, so $k$ is not too big on small graphs,
%  \item  $k \leq 53 / \log_2(n)$ is true for medium sized graphs,
  \item  $k \leq 53 / \log_2(\dmax)$ holds for any graph with $\dmax \leq 14$ (to avoid numerical errors)
  \item  $k = 14$ on graphs with larger max degree (to attempt to ensure the linear system $\mW$ has feasible points).
\end{itemize}
We caution that, for larger graphs ( $n$ greater than a couple thousand), the nonnegative linear system check can still run into numerical issues regardless of the value of $k$, because our algorithm has to compute $\exp(\mA)$ to construct the right-hand-side of the linear program constraint equation $\mW\vx = \vg$. This matrix function calculation $\exp(\mA)$ is notoriously difficult on larger matrices~\cite{moler2003nineteen} (and even on some medium-sized matrices).



{\footnotesize
\bibliographystyle{amsplain}
\bibliography{all-bibliography}
}

\end{document}
